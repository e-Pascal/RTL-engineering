# Конвейеризация

Конвейеризация на (ПЛИС) - это процесс организации выполнения задачи или алгоритма на ПЛИС с использованием конвейерной архитектуры. Конвейерная архитектура представляет собой разделение задачи на несколько последовательных этапов, которые выполняются параллельно. Каждый этап обрабатывает часть данных до передачи его следующему этапу. Таким образом, задача разделяется на несколько более простых этапов, что позволяет увеличить производительность схемы.

Теоритические преимущества использования конвейерного алгоритма на ПЛИС:

1. Увеличение скорости выполнения задачи: конвейерная архитектура позволяет распараллелить выполнение задачи на несколько этапов, что приводит к увеличению общей скорости выполнения.

2. Оптимизация использования ресурсов: конвейеризация модулей ПЛИС позволяет оптимизировать использование доступных ресурсов.

3. Низкий SLACK: использование конвейеризации на ПЛИС позволяет снизить задержку опеределенного модуля, что в итоге уменьшает SLACK всей системы.

Для примера разберем ковейеризацию синхронного 32-битного умножения. Параметрами тактового сигнала возьмем период 1нс, что равняется 1000Мгц(1ГГц). Данный выбор обосновывается тем, что САПР при виде отрицательного слака напрягает хоть какие то силушки для оптимизации имплементации схемы, а именно она нам нужна для определения характеристик и сравнения разных схем.

В качестве отправной точки создадим синхронное умножение 32-битных операндов `a` и `b`, с выводом результата в выходной порт `mult`. 

```SystemVerilog
module multiplier(
  input clk_i,
  input resetn_i,
  input [31:0] a, b,
  output logic [63:0] mult
);

  always_ff @(posedge clk_i) begin
    if (!resetn)
      mult <= 64'h0;
    else
      mult <= a * b;
  end
endmodule
```

[Проведя STA](../Article_3/README.md) данного модуля, мы не увидим главной характеристики дизайна - `Setup time`, так как этот путь определяется от регистра к регистру, а так как в данном дизайне данные поступают со входных портов, а вычесленный результат защелкивается сразу на выход, САПР просто не может вычислить данную характеристику.

![pic/pic1.png](pic/pic1.png)

Для решения данной проблемы необходимо зарегистровать входные данные дополнительными регистрами.

```SystemVerilog
module multiplier(
  input clk_i,
  input resetn_i,
  input [31:0] a, b,
  output logic [63:0] mult
);

logic [31:0] ar, br;

 always_ff @(posedge clk_i) begin
    if( ~resetn_i ) begin
      ar <= 'd0;
      br <= 'd0;
    end else begin
      ar <= a;
      br <= b;
    end
  end

  always_ff @(posedge clk_i) begin
    if( ~resetn_i ) begin
      mult <= 'd0;
    end else begin
      mult <= ar * br;
    end
  end
  
endmodule
```

Теперь при анализе имплементации дизайна выводится информация о таймингах регистров, поэтому данную информацию можно взять за отправную точку.

![pic/pic2.png](pic/pic2.png)

Данная операция (умножение) не имеет определенного логического элемента, как тот же инвертор, для ее выполнения необходима достаточно большая схема, тем более для вычисления столь большой битности, поэтому, чтобы САПР ничего не выдумывал с нуля, он использует уже готовые блоки (DSP), которые имеют большой спектр возможностей вычисления. Именно на данном этапе ожидается самая большая задержка сигнала. Для того, чтобы в этом удостовериться, необходимо нажать на значение WNS, выбрать наибольшее отрицательное значение и нажать `F4`.

![pic/pic3.png](pic/pic3.jpg)

Действительно, предположение подтвердилось, на схеме отображены 2 DSP48 блока, протому как для вычисления 64-битного произведения одного будет недостаточно.

При создании конвейера необходимо определиться, какие операции будут выполняться на каждой стадии, а для большей эффективности необходимо учитывать временные затраты операций, для того, чтобы уравнять SLACK на стадиях и приблизиться к максимальному значению.

В реализации двухстадийного умножителя в каждой стадии будет умножаться одна из половин первого числа на второе, в последней стадии дополнительно к этому будет происходить суммирование результатов этих операций, что добавит задержку вычисления, поэтому наибольшее отрицательное значение SLACK будет ожидаться именно здесь.

Для проверки результата будет использоваться тестбенч, который каждый такт будет присылать на входы случайные значения и вычислять внутри себя результат умножения этих сигналов, который будет взят как истинный. Автоматической проверки реализованно не будет.

Проверка работы модуля умножения за одну стадию.

![1stage](pic/pic4.png)

Первый модуль работает верно, значит можно приступить к небольшому усовершенствованию, добавив одну стадию.

```SystemVerilog
module multiplier(
  input clk_i,
  input resetn_i,
  input [31:0] a, b,
  output logic [63:0] mult
);

logic [31:0] ar1, br1, ar2, br2;
logic [63:0] mult_1st;

logic [63:0] mult_2st, mult_2st_shift;

assign mult_2st = (ar2[31:16] * br2);
assign mult_2st_shift = {mult_2st, 16'b0};

 always_ff @(posedge clk_i) begin
    if( ~resetn_i ) begin
      ar1 <= 'd0;
      br1 <= 'd0;
      ar2 <= 'd0;
      br2 <= 'd0;
    end else begin
      ar1 <= a;
      br1 <= b;
      ar2 <= ar1;
      br2 <= br1;
    end
  end

  always_ff @(posedge clk_i) begin
    if( ~resetn_i ) begin
      mult <= 'd0;
      mult_1st <= 'd0;
    end else begin
      mult <= mult_2st_shift + mult_1st;
      mult_1st <= ar1[15:0] * br1;
    end
  end
  
endmodule
```

Стадия не всегда будет выражена в конвейере, как, например, если бы это был конечный автомат, но их можно отследить по регистрам, участвующих в вычислении. В данном случае результат вычисляется суммой регистров `mult_1st`(произведение 1-й садии) и `mult_2st_shift`(сдвинутое произведение 2-й садии), которые вычисляются регистрами `ar1 br1` и `ar2 br2` соответственно, последние из которых берут новые значения у предыдущих.

![2stage](pic/pic5.png)

Результаты снова верные, значит время узнать, что изменилось в характеристиках дизайна.

стало хуже, надо делать еще стадию 

...ТО БИ КОНТИНУЕД....