# Конвейеризация

Конвейеризация на (ПЛИС) - это процесс организации выполнения задачи или алгоритма на ПЛИС с использованием конвейерной архитектуры. Конвейерная архитектура представляет собой разделение задачи на несколько последовательных этапов, которые выполняются параллельно. Каждый этап обрабатывает часть данных до передачи его следующему этапу. Таким образом, задача разделяется на несколько более простых этапов, что позволяет увеличить производительность схемы.

Теоритические преимущества использования конвейерного алгоритма на ПЛИС:

1. Увеличение скорости выполнения задачи: конвейерная архитектура позволяет распараллелить выполнение задачи на несколько этапов, что приводит к увеличению общей скорости выполнения.

2. Оптимизация использования ресурсов: конвейеризация модулей ПЛИС позволяет оптимизировать использование доступных ресурсов.

3. Низкий SLACK: использование конвейеризации на ПЛИС позволяет снизить задержку опеределенного модуля, что в итоге уменьшает SLACK всей системы.

Для примера разберем ковейеризацию синхронного 32-битного умножения. Параметрами тактового сигнала возьмем период 1нс, что равняется 1000Мгц(1ГГц). Данный выбор обосновывается тем, что САПР при виде отрицательного слака напрягает хоть какие то силушки для оптимизации имплементации схемы, а именно она нам нужна для определения характеристик и сравнения разных схем.

В качестве отправной точки создадим синхронное умножение 32-битных операндов `a` и `b`, с выводом результата в выходной порт `mult`. 

```SystemVerilog
module multiplier(
  input clk_i,
  input resetn_i,
  input [31:0] a, b,
  output logic [63:0] mult
);

  always_ff @(posedge clk_i) begin
    if (!resetn)
      mult <= 64'h0;
    else
      mult <= a * b;
  end
endmodule
```

[Проведя STA](../Article_3/README.md) данного модуля, мы не увидим главной характеристики дизайна - `Setup time`, так как этот путь определяется от регистра к регистру, а так как в данном дизайне данные поступают со входных портов, а вычесленный результат защелкивается сразу на выход, САПР просто не может вычислить данную характеристику.

![pic/pic1.png](pic/pic1.png)

Для решения данной проблемы необходимо зарегистровать входные данные дополнительными регистрами.

```SystemVerilog
module multiplier(
  input clk_i,
  input resetn_i,
  input [31:0] a, b,
  output logic [63:0] mult
);

logic [31:0] ar, br;

 always_ff @(posedge clk_i) begin
    if( ~resetn_i ) begin
      ar <= 'd0;
      br <= 'd0;
    end else begin
      ar <= a;
      br <= b;
    end
  end

  always_ff @(posedge clk_i) begin
    if( ~resetn_i ) begin
      mult <= 'd0;
    end else begin
      mult <= ar * br;
    end
  end
  
endmodule
```

Теперь при анализе имплементации дизайна выводится информация о таймингах регистров, поэтому данную информацию можно взять за отправную точку.

![pic/pic2.png](pic/pic2.png)

Данная операция (умножение) не имеет определенного логического элемента, как тот же инвертор, для ее выполнения необходима достаточно большая схема, тем более для вычисления столь большой битности, поэтому, чтобы САПР ничего не выдумывал с нуля, он использует уже готовые блоки (DSP), которые имеют большой спектр возможностей вычисления. Именно на данном этапе ожидается самая большая задержка сигнала. Для того, чтобы в этом удостовериться, необходимо нажать на значение WNS, выбрать наибольшее отрицательное значение и нажать `F4`.

![pic/pic3.png](pic/pic3.jpg)

Действительно, предположение подтвердилось, на схеме отображены 2 DSP48 блока, протому как для вычисления 64-битного произведения одного будет недостаточно.

...ТО БИ КОНТИНУЕД....